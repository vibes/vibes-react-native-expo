import {
  ConfigPlugin,
  withDangerousMod,
  withXcodeProject,

} from "@expo/config-plugins";
import fs from "fs";
import path from "path";

import type { ConfigPluginProps } from "../types";
import { getBridgeHeaderObjC } from "../iosNativeContent";

// Creates VibesPushEmitter files
export const withVibesPushEmitterFiles: ConfigPlugin<ConfigPluginProps> = (
  config,
  props,
) => {
  return withDangerousMod(config, [
    "ios",
    async (config) => {
      const projectName = config.modRequest.projectName;
      const iosPath = config.modRequest.platformProjectRoot;

      const VibesPushEmitterHContent = getPushEmitterHeaderObjC(projectName ?? "");
      const VibesPushEmitterMContent = getPushEmitterImplementationObjC(projectName ?? "");

      const VibesPushEmitterHPath = path.join(
        iosPath,
        projectName ?? "",
        "VibesPushEmitter.h",
      );
      fs.writeFileSync(VibesPushEmitterHPath, VibesPushEmitterHContent);

      const VibesPushEmitterMPath = path.join(
        iosPath,
        projectName ?? "",
        "VibesPushEmitter.m",
      );
      fs.writeFileSync(VibesPushEmitterMPath, VibesPushEmitterMContent);

      return config;
    },
  ]);
};

// Adds push emitter files to XCode Project
export const withVibesPushEmitterXcodeProject: ConfigPlugin<ConfigPluginProps> = (
  config,
) => {
  return withXcodeProject(config, (config) => {
    const xcodeProject = config.modResults;
    const projectName = config.modRequest.projectName;

    const nativeTarget = xcodeProject.getFirstTarget()?.firstTarget;

    if (!nativeTarget) {
      throw new Error("Could not find native target in Xcode project");
    }

    const projectGroupKey = xcodeProject.findPBXGroupKey({ name: projectName });
    if (!projectGroupKey) {
      throw new Error(
        `Could not find project group for project "${projectName}".`,
      );
    }

    const headerPath = path.join(projectName ?? "", "VibesPushEmitter.h");
    const implPath = path.join(projectName ?? "", "VibesPushEmitter.m");

    xcodeProject.addFile(headerPath, projectGroupKey, {
      lastKnownFileType: "sourcecode.c.h",
      sourceTree: "SOURCE_ROOT",
    });

    xcodeProject.addSourceFile(
      implPath,
      {
        target: nativeTarget.uuid,
        sourceTree: "SOURCE_ROOT",
      },
      projectGroupKey,
    );

    return config;
  });
};



// Push emitter
const getPushEmitterHeaderObjC = (projectName: string) => `//
//  VibesPushEmitter.h
//  ${projectName}
//
//  Generated by expo-vibes-sdk plugin
//

#import <Foundation/Foundation.h>
#import <React/RCTEventEmitter.h>

@interface VibesPushEmitter : RCTEventEmitter <RCTBridgeModule>

+ (void)setInitialNotification:(NSDictionary *)userInfo;
+ (void)sendPushOpenedEvent:(NSDictionary *)userInfo;
+ (void)sendPushReceivedEvent:(NSDictionary *)userInfo;

@end
`;


const getPushEmitterImplementationObjC = (projectName: string): string => `//
//  VibesPushEmitter.m
//  ${projectName}
//
//  Generated by expo-vibes-sdk plugin
//

#import <Foundation/Foundation.h>
#import "VibesPushEmitter.h"

static VibesPushEmitter *emitter = nil;
static NSDictionary *initialNotification = nil;

@implementation VibesPushEmitter

RCT_EXPORT_MODULE()

- (NSArray<NSString *> *)supportedEvents {
  return @[@"pushReceived", @"pushOpened"];
}

- (instancetype)init {
  self = [super init];
  if (self) {
    emitter = self;
  }
  return self;
}

+ (void)setInitialNotification:(NSDictionary *)userInfo {
  initialNotification = userInfo;
}

-(void)addListener:(NSString *)eventName {
  [super addListener:eventName];
  if([eventName isEqualToString:@"pushOpened"] && initialNotification != nil) {
    [emitter sendEventWithName:@"pushOpened" body: initialNotification];
    initialNotification = nil;
  }
}

+ (void)sendPushOpenedEvent:(NSDictionary *)userInfo
{
  [emitter sendEventWithName:@"pushOpened" body: userInfo];
}

+ (void)sendPushReceivedEvent:(NSDictionary *)userInfo
{
  [emitter sendEventWithName:@"pushReceived" body: userInfo];}

@end
`;