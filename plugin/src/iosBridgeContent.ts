// Anchors RegExp
export const MATCH_APP_DELEGATE_IMPORTS_OBJCPP = /#import "AppDelegate\.h"/;
export const MATCH_APP_DELEGATE_IMPORTS_SWIFT = /@UIApplicationMain/;
export const MATCH_FINISH_LAUNCHING_METHOD_OBJCPP =
  /-\s*\(BOOL\)\s*application:\s*\(UIApplication\s*\*\s*\)\s*\w+\s+didFinishLaunchingWithOptions:/g;
export const MATCH_FINISH_LAUNCHING_METHOD_SWIFT =
  /\bsuper\.application\(\w+?, didFinishLaunchingWithOptions: \w+?\)/g;
export const MATCH_DID_REGISTER_REMOTE_NOTIFICATIONS_OBJCPP =
  /-\s*\(void\)\s*application:\s*\(UIApplication\s*\*\s*\)\s*\w+\s+didRegisterForRemoteNotificationsWithDeviceToken:/g;

// Objective C Bridge for Vibes configuration
export const getBridgeHeaderObjC = (projectName: string) => `//
//  VibesBridge.h
//  ${projectName}
//
//  Generated by expo-vibes-sdk plugin
//

#import <Foundation/Foundation.h>

@interface VibesBridge : NSObject

+ (void)configureVibes;
+ (void) requestAuthorizationForNotifications;
+ (void)setPushToken:(NSData *) data;

@end
`;

export const getBridgeImplementationObjC = (
  projectName: string,
  appId: string,
  appUrl?: string,
): string => {
  const apiUrlValue = appUrl ? `@"${appUrl}"` : "NULL";
  const trackingApiUrlValue = appUrl ? `@"${appUrl}"` : "NULL";

  return `//
//  VibesBridge.m
//  ${projectName}
//
//  Generated by expo-vibes-sdk plugin
//

#import <Foundation/Foundation.h>
#import "VibesBridge.h"
@import VibesPush;
#import <UserNotifications/UNUserNotificationCenter.h>

@implementation VibesBridge

+ (void)configureVibes
{
 VibesConfiguration *vibesConfig = [[VibesConfiguration alloc] initWithAdvertisingId:NULL
                                         apiUrl:${apiUrlValue}
                                     trackingApiUrl:${trackingApiUrlValue}
                                         logger:NULL
                                       storageType:VibesStorageEnumUSERDEFAULTS
                                    trackedEventTypes:[@[] mutableCopy]];
 [Vibes configureWithAppId:@"${appId}"
       configuration:vibesConfig];
 [[Vibes shared] registerDevice];
 NSLog(@"[VIBES] <config completed> %@");
 [self requestAuthorizationForNotifications];
}

+ (void)requestAuthorizationForNotifications {
#if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_10_0
  [[UIApplication sharedApplication] registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:(UIUserNotificationTypeSound | UIUserNotificationTypeAlert | UIUserNotificationTypeBadge) categories:nil]];
  [[UIApplication sharedApplication] registerForRemoteNotifications];
#else
  UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];
  center.delegate = self;
  [center requestAuthorizationWithOptions:(UNAuthorizationOptionSound | UNAuthorizationOptionAlert | UNAuthorizationOptionBadge)
             completionHandler:^(BOOL granted, NSError *_Nullable error) {
   NSLog(@"[VIBES] <requesting permissions>");
   if (error) {
      NSLog(@"ERROR registering for push: %@ - %@", error.localizedFailureReason, error.localizedDescription);
    } else if (granted) {
     NSLog(@"[VIBES] <permission granted>");
      dispatch_async(dispatch_get_main_queue(), ^{
                [[UIApplication sharedApplication] registerForRemoteNotifications];
              });
    } else {
      NSLog(@"authorization denied for push");
    }
  }];
#endif
}

+ (void)setPushToken:(NSData *) data; {
 NSLog(@"[VIBES] <set push token, > %@", data);
 [[Vibes shared] setPushTokenFromData:data];
 NSLog(@"[VIBES] <completed> %@");
}

@end
`;
};

// Objcpp App Delegate Vibes Bridge

export const IMPORT_VIBES_BRIDGE_OBJCPP = `#import "../VibesBridge.h"`;
export const CONFIGURE_VIBES_BRIDGE_OBJCPP = `  [VibesBridge configureVibes];`;

// Swift App Delegate Vibes Config
export const IMPORT_VIBES_PACKAGE_SWIFT = `import VibesPush`;

export const getOptionalConfigLinesSwift = (appId: string, appUrl: string) => [
  `    let configuration = VibesConfiguration(`,
  `      advertisingId: nil,`,
  `      apiUrl: "${appUrl}",`,
  `      logger: nil,`,
  `      storageType: .USERDEFAULTS,`,
  `      trackedEventTypes: [TrackedEventType.launch, TrackedEventType.clickthru] as NSArray`,
  `    )`,
  `    Vibes.configure(appId: "${appId}", configuration: configuration)`,
];

export const getConfigLineSwift = (appId: string) =>
  `    Vibes.configure(appId: "${appId}")`;






export const getAppDelegate = (projectName: string) => `#import "AppDelegate.h"
// @generated begin vibes-bridge-import - expo prebuild (DO NOT MODIFY) sync-7d16f35da43c3281ca917ffa59f4905977c29efb
#import "../VibesBridge.h"
// @generated end vibes-bridge-import

#import <React/RCTBundleURLProvider.h>
#import <React/RCTLinkingManager.h>

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
// @generated begin vibes-bridge-config - expo prebuild (DO NOT MODIFY) sync-b6b1b3947d329bd06a3bfd35ca205094fde25c12
  [VibesBridge configureVibes];
// @generated end vibes-bridge-config
  self.moduleName = @"main";

  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  return [self bundleURL];
}

- (NSURL *)bundleURL
{
#if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@".expo/.virtual-metro-entry"];
#else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];
#endif
}

// Linking API
- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url options:(NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options {
  return [super application:application openURL:url options:options] || [RCTLinkingManager application:application openURL:url options:options];
}

// Universal Links
- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray<id<UIUserActivityRestoring>> * _Nullable))restorationHandler {
  BOOL result = [RCTLinkingManager application:application continueUserActivity:userActivity restorationHandler:restorationHandler];
  return [super application:application continueUserActivity:userActivity restorationHandler:restorationHandler] || result;
}

// Explicitly define remote notification delegates to ensure compatibility with some third-party libraries
- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken
{
  NSLog(@"[VIBES] <did register for remote notfs>");
  
  [VibesBridge setPushToken:deviceToken];
  return [super application:application didRegisterForRemoteNotificationsWithDeviceToken:deviceToken];
}

// Explicitly define remote notification delegates to ensure compatibility with some third-party libraries
- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error
{
  NSLog(@"[VIBES] <did fail to register for notfs> %@", error.localizedDescription);
  return [super application:application didFailToRegisterForRemoteNotificationsWithError:error];
}

// Explicitly define remote notification delegates to ensure compatibility with some third-party libraries
- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
{
  return [super application:application didReceiveRemoteNotification:userInfo fetchCompletionHandler:completionHandler];
}

@end
`;
